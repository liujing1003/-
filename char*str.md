# char* str和char str[]的区别


    在定义的时候，其实char* s1与char s2[]是有很大区别的。s1这个指针其实是指向一段常量字符串，存储在静态储存区，这段字符串是只读的，不能被修改。然而，s2这只是个局部变量数组，在定义它的时候，有两份备份，一份存储在stack上，一份存储在静态存储区，所以可以被修改。
    举个例子，假如我定义了一个函数，返回的是char*的类型变量，当这个函数运行结束时，所定义的字符串在静态存储区，并不会消亡，当整个程序结束时，才会消亡。如下图所示，我有返回char*的str（）函数。

![](http://img.my.csdn.net/uploads/201301/31/1359562868_8316.jpg)

  如上图所示，我赋给的字符串值为“aaaa”，从而，这串aaaa也就存储在静态存储区上了。挡在main函数中调用这个函数的时候

![](http://img.my.csdn.net/uploads/201301/31/1359563194_1794.jpg)

输出结果是

![](http://img.my.csdn.net/uploads/201301/31/1359563539_3506.jpg)

结果没有任何问题，这说明，在str（）函数运行结束时，字符串aaaa还是存在的。

这时，如果我们换一个函数，如下图：

![](http://img.my.csdn.net/uploads/201301/31/1359563717_2463.jpg)

在这个函数中，我定义了一个局部变量char数组，赋值依然是aaaa。在main函数中调用这个函数。

![](http://img.my.csdn.net/uploads/201301/31/1359563935_7331.jpg)

运行结果为:

![](http://img.my.csdn.net/uploads/201301/31/1359564001_2443.jpg)

我们从结果来看，所返回的指针为一串乱码，这是因为char s1[]定以后，在程序中有两份拷贝，一份在静态存储区中，一份在stack中，当str1（）函数运行退出时，stack要被清空，从而内存也就被清空了，返回的是一个被释放的内存地址，所以打印出来也就是一段乱码了。

从上面的例子中可以得到两种指针的本质区别。另外还有一个例子可以验证。

![](http://img.my.csdn.net/uploads/201301/31/1359564608_5012.jpg)

在这个例子中，我定义了四个指针，两个char*指向同一个字符串，由于该字符串存储在静态储存空间里面，所以他们所指向的地址是一样的。同时我又定义了两个char[]类型的指针，他们两个也指向一串相同的字符串，由于这个字符串有备份，所以，s3和s4是不相同的。从下面运行结果，我们可以看出：

![](http://img.my.csdn.net/uploads/201301/31/1359564804_9045.jpg)
